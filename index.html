<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3D Галактика</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #stats {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 16px 20px 16px 20px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      min-width: 180px;
      z-index: 10;
    }
    .stat-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .stat-color {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      margin-right: 10px;
      display: inline-block;
      border: 2px solid #fff;
    }
    .stat-label {
      font-weight: bold;
      margin-right: 8px;
    }
    .stat-count {
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="stats"></div>
  <canvas id="relations" width="400" height="320" style="position:absolute;top:20px;right:20px;z-index:10;background:rgba(0,0,0,0.7);border-radius:10px;"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // Сцена, камера, рендерер
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Параметры галактики
    const starCount = 20000;
    const galaxyRadius = 20;
    const arms = 4;
    const armSpread = 0.5;
    const starsGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const color = new THREE.Color();

    for (let i = 0; i < starCount; i++) {
      // Радиус с большей плотностью к центру
      const t = Math.random();
      const radius = Math.pow(t, 1.8) * galaxyRadius; // экспоненциальное распределение
      const arm = i % arms;
      // Отклонение от рукава зависит от расстояния до центра
      const deviation = (1 - radius / galaxyRadius) * 2.5 + 0.2;
      const angle = (arm / arms) * Math.PI * 2 + radius * 0.3 + (Math.random() - 0.5) * deviation;
      const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.5;
      const y = (Math.random() - 0.5) * 1.5;
      const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.5;
      positions.push(x, y, z);

      // Цвета: белый, голубой, желтый
      color.setHSL(0.6 + Math.random() * 0.4, 0.7, 0.7 + Math.random() * 0.3);
      colors.push(color.r, color.g, color.b);
    }

    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const starsMaterial = new THREE.PointsMaterial({
      size: 0.15,
      vertexColors: true
    });

    // Создаём группу для всей галактики
    const galaxyGroup = new THREE.Group();
    scene.add(galaxyGroup);

    const stars = new THREE.Points(starsGeometry, starsMaterial);
    galaxyGroup.add(stars);

    camera.position.z = 35;

    // --- Симуляция фракций и космолетов ---
    const factionCount = 6;
    const factionColors = [
      0xff0000, // красный
      0x00ff00, // зелёный
      0x0000ff, // синий
      0xffff00, // жёлтый
      0xff00ff, // фиолетовый
      0x00ffff  // бирюзовый
    ];

    // Выбираем стартовые позиции для космолетов (разные рукава, разный радиус)
    const shipStartPositions = [];
    for (let i = 0; i < factionCount; i++) {
      const arm = i % arms;
      const angle = (arm / arms) * Math.PI * 2 + (i / factionCount) * Math.PI * 2;
      const radius = galaxyRadius * (0.6 + 0.3 * Math.random());
      const x = Math.cos(angle) * radius;
      const y = (Math.random() - 0.5) * 2;
      const z = Math.sin(angle) * radius;
      shipStartPositions.push(new THREE.Vector3(x, y, z));
    }

    // Создаём космолеты
    const ships = [];
    for (let i = 0; i < factionCount; i++) {
      const geometry = new THREE.SphereGeometry(0.5, 16, 16);
      const material = new THREE.MeshBasicMaterial({ color: factionColors[i] });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(shipStartPositions[i]);
      galaxyGroup.add(mesh);
      ships.push({ mesh, faction: i, captured: new Set() });
    }

    // Массив для хранения владельца каждой звезды
    const starOwners = new Array(starCount).fill(-1);
    // --- История владельцев звёзд для корректной статистики атак ---
    const starPrevOwners = new Array(starCount).fill(-1);

    // --- Ресурсы звёзд ---
    const starResources = [];
    for (let i = 0; i < starCount; i++) {
      // Радиус звезды от центра
      const x = positions[i*3], y = positions[i*3+1], z = positions[i*3+2];
      const r = Math.sqrt(x*x + y*y + z*z);
      // Центр: максимум, к краю спад медленнее, но тоже к нулю
      // Используем нормальное распределение с шумом
      let base = 0;
      if (r < galaxyRadius * 0.2) {
        // Центр: резкий спад
        base = 10 * (1 - Math.pow(r / (galaxyRadius * 0.2), 2));
      } else {
        // Края: плавный спад
        base = 10 * Math.exp(-((r - galaxyRadius * 0.2) / (galaxyRadius * 0.8)));
      }
      // Добавим нормальный шум
      const noise = (Math.random() + Math.random() + Math.random()) / 3 - 0.5;
      let resources = Math.max(0, Math.min(10, base + noise * 2));
      starResources.push(resources);
    }

    // --- Ресурсы фракций ---
    for (let i = 0; i < factionCount; i++) {
      ships[i].resources = 10.0;
    }

    // --- Управление камерой колесиком ---
    let minZoom = 8;
    let maxZoom = 80;
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      camera.position.z += delta * 2.5;
      camera.position.z = Math.max(minZoom, Math.min(maxZoom, camera.position.z));
    }, { passive: false });

    function animate() {
      requestAnimationFrame(animate);
      galaxyGroup.rotation.y += 0.0015;
      galaxyGroup.rotation.x += 0.0005;

      for (let i = 0; i < factionCount; i++) {
        const ship = ships[i];
        // --- Новый маршрут: космолет может лететь только к соседней захваченной звезде или стартовой позиций ---
        // Список доступных точек для перемещения: стартовая позиция + все уже захваченные звезды
        let moveFrom = ship.mesh.position.clone();
        let moveOptions = [shipStartPositions[i]];
        for (const idx of ship.captured) {
          const sx = positions[idx*3], sy = positions[idx*3+1], sz = positions[idx*3+2];
          moveOptions.push(new THREE.Vector3(sx, sy, sz));
        }
        // Найти ближайшую точку из moveOptions к текущей позиции
        let minMoveDist = Infinity;
        let nearestMove = moveFrom;
        for (const pt of moveOptions) {
          const d = ship.mesh.position.distanceTo(pt);
          if (d < minMoveDist) {
            minMoveDist = d;
            nearestMove = pt;
          }
        }
        // Теперь ищем цель только среди звёзд, которые доступны из ближайшей захваченной точки
        // (то есть, расстояние до цели не больше некоторого радиуса, например 3)
        let bestIdx = -1;
        let bestScore = -Infinity;
        let bestDist = Infinity;
        for (let j = 0; j < starCount; j++) {
          if (starOwners[j] === -1) {
            const sx = positions[j*3], sy = positions[j*3+1], sz = positions[j*3+2];
            const starPos = new THREE.Vector3(sx, sy, sz);
            const distToMove = starPos.distanceTo(nearestMove);
            if (distToMove < 3) { // только если звезда рядом с уже захваченной
              const distToShip = starPos.distanceTo(ship.mesh.position);
              const score = starResources[j] - distToShip * 0.05;
              if (score > bestScore || (score === bestScore && distToShip < bestDist)) {
                bestScore = score;
                bestIdx = j;
                bestDist = distToShip;
              }
            }
          }
        }
        // Если нет доступных свободных, ищем атаку среди соседних чужих звёзд
        let attackIdx = -1;
        let attackScore = -Infinity;
        let attackDist = Infinity;
        if (bestIdx === -1 && ship.resources >= 5) {
          for (let j = 0; j < starCount; j++) {
            if (starOwners[j] !== i) {
              const sx = positions[j*3], sy = positions[j*3+1], sz = positions[j*3+2];
              const starPos = new THREE.Vector3(sx, sy, sz);
              const distToMove = starPos.distanceTo(nearestMove);
              if (distToMove < 3) {
                const distToShip = starPos.distanceTo(ship.mesh.position);
                const score = starResources[j] - distToShip * 0.05 - 8;
                if (score > attackScore || (score === attackScore && distToShip < attackDist)) {
                  attackScore = score;
                  attackIdx = j;
                  attackDist = distToShip;
                }
              }
            }
          }
        }
        let targetIdx = bestIdx;
        let isAttack = false;
        if (targetIdx === -1 && attackIdx !== -1 && attackScore > 2) {
          targetIdx = attackIdx;
          isAttack = true;
        }
        // --- Избегание других космолетов ---
        let avoidVec = new THREE.Vector3(0, 0, 0);
        let avoidCount = 0;
        for (let k = 0; k < factionCount; k++) {
          if (k !== i) {
            const otherPos = ships[k].mesh.position;
            const dist = ship.mesh.position.distanceTo(otherPos);
            if (dist < 5) { // радиус избегания
              let diff = ship.mesh.position.clone().sub(otherPos).normalize().multiplyScalar(1 / (dist + 0.1));
              avoidVec.add(diff);
              avoidCount++;
            }
          }
        }
        if (avoidCount > 0) {
          avoidVec.divideScalar(avoidCount);
        }

        if (targetIdx !== -1) {
          const tx = positions[targetIdx*3], ty = positions[targetIdx*3+1], tz = positions[targetIdx*3+2];
          const target = new THREE.Vector3(tx, ty, tz);
          let dir = target.clone().sub(ship.mesh.position);
          const dist = dir.length();
          if (dist > 0.2) {
            dir.normalize();
            // Добавляем избегание других космолетов
            if (avoidCount > 0) {
              dir.add(avoidVec.multiplyScalar(1.5)).normalize();
            }
            ship.mesh.position.add(dir.multiplyScalar(0.15));
          } else {
            if (isAttack && ship.resources >= 5) {
              ship.resources -= 5;
            }
            ship.resources += starResources[targetIdx];
            if (starOwners[targetIdx] !== -1 && starOwners[targetIdx] !== i) {
              starPrevOwners[targetIdx] = starOwners[targetIdx];
            }
            starOwners[targetIdx] = i;
            ship.captured.add(targetIdx);
          }
        }
        ship.mesh.lookAt(camera.position);
      }

      // Обновляем цвета захваченных звёзд
      const colorAttr = starsGeometry.getAttribute('color');
      for (let i = 0; i < starCount; i++) {
        if (starOwners[i] !== -1) {
          const c = new THREE.Color(factionColors[starOwners[i]]);
          colorAttr.setXYZ(i, c.r, c.g, c.b);
        }
      }
      colorAttr.needsUpdate = true;

      updateStats();
      drawRelations();
      renderer.render(scene, camera);
    }
    animate();

    // Адаптация к размеру окна
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function updateStats() {
      const statsDiv = document.getElementById('stats');
      let html = '';
      for (let i = 0; i < factionCount; i++) {
        const color = '#' + factionColors[i].toString(16).padStart(6, '0');
        const captured = ships[i].captured.size;
        const percent = ((captured / starCount) * 100).toFixed(2);
        html += `<div class="stat-row"><span class="stat-color" style="background:${color}"></span><span class="stat-label">Фракция ${i+1}</span><span class="stat-count">${captured} (${percent}%)<br>Ресурсы: ${ships[i].resources.toFixed(2)}</span></div>`;
      }
      statsDiv.innerHTML = html;
    }

    function drawRelations() {
      const canvas = document.getElementById('relations');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Подписи фракций
      const margin = 60;
      const nodeRadius = 18;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const nodePositions = [];
      for (let i = 0; i < factionCount; i++) {
        const angle = (i / factionCount) * Math.PI * 2 - Math.PI/2;
        const x = centerX + Math.cos(angle) * (canvas.width/2 - margin);
        const y = centerY + Math.sin(angle) * (canvas.height/2 - margin);
        nodePositions.push({x, y});
      }
      // Подсчёт: кто сколько чьих систем захватил
      // relations[a][b] = сколько фракция a захватила у фракции b
      const relations = Array.from({length: factionCount}, () => Array(factionCount).fill(0));
      for (let i = 0; i < starCount; i++) {
        const owner = starOwners[i];
        if (owner !== -1 && ships[owner].captured.has(i)) {
          // Найти предыдущего владельца (если был)
          // Для простоты: если система была захвачена атакой, то она была у другой фракции
          // Можно хранить историю, но сейчас считаем только текущий захват
          // relations[owner][prevOwner]++
          // Здесь не реализовано, т.к. история не ведётся
        }
      }
      // Но мы можем считать сколько раз фракция потратила ресурсы на атаку (isAttack)
      // Для этого нужно хранить историю атак
      if (!window.attackHistory) window.attackHistory = [];
      // Нарисовать связи
      for (const attack of window.attackHistory) {
        const from = attack.attacker;
        const to = attack.defender;
        if (from !== to) {
          relations[from][to]++;
        }
      }
      // Рисуем линии
      for (let i = 0; i < factionCount; i++) {
        for (let j = 0; j < factionCount; j++) {
          if (i !== j && relations[i][j] > 0) {
            const a = nodePositions[i];
            const b = nodePositions[j];
            ctx.save();
            ctx.strokeStyle = '#' + factionColors[i].toString(16).padStart(6, '0');
            ctx.globalAlpha = 0.3 + 0.7 * Math.min(1, relations[i][j]/5);
            ctx.lineWidth = 2 + Math.min(8, relations[i][j]);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
            ctx.restore();
            // Подпись количества
            const mx = (a.x + b.x) / 2;
            const my = (a.y + b.y) / 2;
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 15px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(relations[i][j], mx, my-6);
            ctx.restore();
          }
        }
      }
      // Рисуем узлы
      for (let i = 0; i < factionCount; i++) {
        const pos = nodePositions[i];
        ctx.save();
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI*2);
        ctx.fillStyle = '#' + factionColors[i].toString(16).padStart(6, '0');
        ctx.globalAlpha = 0.9;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 15px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Ф'+(i+1), pos.x, pos.y+5);
        ctx.restore();
      }
    }
  </script>
</body>
</html>